#include "atom_api_message.h"

#define R enum caut_status
#define EI struct caut_encode_iter
#define DI struct caut_decode_iter
#define FSET(FS,IX) ((FS) & (1ull << (IX)))

/* type descriptors */
const caut_type_descriptors_atom_api_t type_descriptors = {
  {
    .name = "res_send",
    .hash = { 0x7B,0xDF,0x1A,0x31,0x49,0xB2,0xAC,0x77,0xEC,0x06,0xA2,0x2D,0x26,0x74,0x69,0xBF,0x44,0xA9,0xBB,0xD2 },
    .encode = (gen_encode*)encode_res_send,
    .decode = (gen_decode*)decode_res_send,
    .min_size = 1,
    .max_size = 1,
  },
  {
    .name = "res_info",
    .hash = { 0x91,0xAA,0x13,0x22,0x01,0x0C,0xA6,0xF3,0x75,0x6D,0x0A,0xAA,0x2D,0x19,0x8E,0xB2,0xDE,0xA5,0x50,0xDC },
    .encode = (gen_encode*)encode_res_info,
    .decode = (gen_decode*)decode_res_info,
    .min_size = 21,
    .max_size = 21,
  },
  {
    .name = "res_connect",
    .hash = { 0xE5,0xFE,0x6C,0x8D,0xFF,0xF1,0x8E,0xAB,0x72,0x82,0x27,0x51,0x79,0xE5,0x36,0x54,0x7A,0xC4,0xB3,0x42 },
    .encode = (gen_encode*)encode_res_connect,
    .decode = (gen_decode*)decode_res_connect,
    .min_size = 1,
    .max_size = 1,
  },
  {
    .name = "radio_frame",
    .hash = { 0x25,0x21,0xFB,0xDE,0xC6,0xDA,0x77,0xF0,0x03,0x7C,0x98,0xDF,0xA8,0x0B,0x20,0x74,0xA3,0x08,0xBB,0x82 },
    .encode = (gen_encode*)encode_radio_frame,
    .decode = (gen_decode*)decode_radio_frame,
    .min_size = 1,
    .max_size = 1,
  },
  {
    .name = "res_poll",
    .hash = { 0xEF,0x37,0x6C,0x42,0x84,0xE5,0x9D,0xC1,0x33,0x44,0xFF,0x00,0x72,0x5D,0x08,0xC4,0x51,0x46,0xC7,0xC0 },
    .encode = (gen_encode*)encode_res_poll,
    .decode = (gen_decode*)decode_res_poll,
    .min_size = 1,
    .max_size = 1,
  },
  {
    .name = "cmd_send",
    .hash = { 0x75,0x37,0x8E,0x3C,0x10,0x94,0xDA,0x6D,0x38,0xE6,0x67,0x01,0xFB,0xA6,0x7F,0xEC,0xCD,0x8E,0x0E,0xE2 },
    .encode = (gen_encode*)encode_cmd_send,
    .decode = (gen_decode*)decode_cmd_send,
    .min_size = 2,
    .max_size = 2,
  },
  {
    .name = "cmd_poll",
    .hash = { 0x87,0xAE,0x40,0x91,0xED,0xCC,0x8E,0xCD,0xF9,0x73,0xFE,0x3E,0xF8,0xD3,0x7F,0x8E,0x60,0x1A,0xE0,0xCB },
    .encode = (gen_encode*)encode_cmd_poll,
    .decode = (gen_decode*)decode_cmd_poll,
    .min_size = 1,
    .max_size = 1,
  },
  {
    .name = "cmd_mac",
    .hash = { 0x28,0xCA,0xED,0x17,0x72,0xFB,0x1C,0x68,0xAA,0xDE,0x8B,0x3C,0x4B,0xA6,0xAB,0xDC,0x1B,0xFD,0x49,0x81 },
    .encode = (gen_encode*)encode_cmd_mac,
    .decode = (gen_decode*)decode_cmd_mac,
    .min_size = 1,
    .max_size = 1,
  },
  {
    .name = "cmd_info",
    .hash = { 0x14,0x1E,0xAF,0x55,0xC7,0xAF,0x6F,0x09,0x24,0x6F,0xD6,0x89,0xFC,0xA3,0xB1,0x8A,0xB0,0x9E,0x1A,0x50 },
    .encode = (gen_encode*)encode_cmd_info,
    .decode = (gen_decode*)decode_cmd_info,
    .min_size = 1,
    .max_size = 1,
  },
  {
    .name = "cmd_connected",
    .hash = { 0x1C,0x71,0x94,0xAF,0x95,0xE6,0x73,0x28,0x1A,0xDE,0x84,0x2C,0xA0,0x4C,0x55,0xA9,0x77,0x16,0xF2,0x9C },
    .encode = (gen_encode*)encode_cmd_connected,
    .decode = (gen_decode*)decode_cmd_connected,
    .min_size = 1,
    .max_size = 1,
  },
  {
    .name = "arr_u8_32",
    .hash = { 0x50,0x51,0x07,0x7D,0xE0,0xF3,0x75,0x5B,0x22,0xB9,0xAA,0xFA,0x6B,0xA8,0xFB,0x38,0xFE,0xD6,0x01,0xFF },
    .encode = (gen_encode*)encode_arr_u8_32,
    .decode = (gen_decode*)decode_arr_u8_32,
    .min_size = 32,
    .max_size = 32,
  },
  {
    .name = "connection",
    .hash = { 0xB9,0xC4,0x88,0x2E,0xF5,0xC8,0x47,0x24,0x55,0x11,0x13,0xF0,0x56,0xBA,0x01,0x75,0x7A,0x70,0xE8,0x99 },
    .encode = (gen_encode*)encode_connection,
    .decode = (gen_decode*)decode_connection,
    .min_size = 56,
    .max_size = 56,
  },
  {
    .name = "quick_connect",
    .hash = { 0xEB,0x97,0x31,0xDB,0x19,0xB2,0xEA,0xB4,0x27,0x45,0x91,0xC3,0x90,0x64,0x97,0xB3,0x22,0x1D,0x2F,0x0B },
    .encode = (gen_encode*)encode_quick_connect,
    .decode = (gen_decode*)decode_quick_connect,
    .min_size = 60,
    .max_size = 60,
  },
  {
    .name = "req_connect",
    .hash = { 0xBE,0x8D,0x98,0x3B,0x3D,0xB1,0xD9,0xBB,0xD8,0x4D,0xCC,0x01,0xA3,0xE2,0x8C,0xA4,0x50,0x36,0xD0,0xFC },
    .encode = (gen_encode*)encode_req_connect,
    .decode = (gen_decode*)decode_req_connect,
    .min_size = 1,
    .max_size = 1,
  },
  {
    .name = "cmd_connect",
    .hash = { 0x89,0x52,0x91,0x93,0x2F,0xF8,0x92,0x3B,0x16,0xC1,0x17,0x13,0x05,0x68,0x37,0xBC,0xC9,0x32,0xE4,0xFF },
    .encode = (gen_encode*)encode_cmd_connect,
    .decode = (gen_decode*)decode_cmd_connect,
    .min_size = 2,
    .max_size = 2,
  },
  {
    .name = "res_sleep",
    .hash = { 0x20,0x5E,0x90,0x21,0xCC,0x3C,0x1B,0x8C,0x86,0x8C,0x5E,0xD5,0x56,0xDE,0x83,0x88,0x09,0x6A,0x7F,0x46 },
    .encode = (gen_encode*)encode_res_sleep,
    .decode = (gen_decode*)decode_res_sleep,
    .min_size = 1,
    .max_size = 1,
  },
  {
    .name = "cmd_sleep",
    .hash = { 0x05,0x86,0xAC,0x45,0xE9,0x12,0x31,0x94,0x89,0x56,0xC3,0xFF,0xFE,0x72,0x12,0x02,0x79,0x1B,0x13,0xF5 },
    .encode = (gen_encode*)encode_cmd_sleep,
    .decode = (gen_decode*)decode_cmd_sleep,
    .min_size = 1,
    .max_size = 1,
  },
  {
    .name = "cmd",
    .hash = { 0x37,0x2A,0xB5,0xC2,0xB6,0x43,0x94,0xBA,0xF3,0x5B,0xC5,0x63,0x2F,0x7A,0x7F,0xE2,0x6D,0x9C,0xD3,0x58 },
    .encode = (gen_encode*)encode_cmd,
    .decode = (gen_decode*)decode_cmd,
    .min_size = 2,
    .max_size = 2,
  },
  {
    .name = "txn",
    .hash = { 0x73,0x55,0xF8,0xC1,0xF6,0xDC,0x1B,0xF7,0x8C,0xC3,0xAD,0xCF,0xF7,0x39,0x8F,0x78,0x53,0x64,0xCC,0x1E },
    .encode = (gen_encode*)encode_txn,
    .decode = (gen_decode*)decode_txn,
    .min_size = 4,
    .max_size = 4,
  }
};

/* message interface */
R encode_message_atom_api(EI * const _iter, struct message_atom_api const * const _obj) {
  const struct caut_type_descriptor * const desc = &type_descriptors[_obj->_type];
  size_t _data_position = 0;
  uint8_t _data_len = 0;
  void * len_ptr = 0;

  STATUS_CHECK(__caut_encode_reserve(_iter, LENGTH_WIDTH_atom_api, &len_ptr));
  STATUS_CHECK(__caut_encode_raw_bytes(_iter, desc->hash, TYPE_TAG_WIDTH_atom_api));
  _data_position = _iter->position;
  STATUS_CHECK(desc->encode(_iter, &_obj->_data));
  _data_len = (uint8_t)(_iter->position - _data_position);

  memmove(len_ptr, &_data_len, sizeof(_data_len));

  return caut_status_ok;
}

R decode_message_header_atom_api(DI * const _iter, struct message_header_atom_api * const _header) {
  uint8_t length = 0;
  STATUS_CHECK(decode_u8(_iter, &length));
  _header->length = length;
  STATUS_CHECK(__caut_decode_raw_bytes(_iter, _header->tag, sizeof(_header->tag)));

  return caut_status_ok;
}

R decode_message_atom_api(DI * const _iter, struct message_header_atom_api const * const _header, struct message_atom_api * const _obj) {
  const struct caut_type_descriptor * desc = 0;

  for (size_t i = 0; i < ARR_LEN(type_descriptors); i++) {
    if (0 == memcmp(_header->tag, type_descriptors[i].hash, TYPE_TAG_WIDTH_atom_api)) {
      desc = &type_descriptors[i];
      _obj->_type = (enum type_index_atom_api)i;
      break;
    }
  }

  if (0 == desc) {
    return caut_status_invalid_tag;
  } else {
    STATUS_CHECK(desc->decode(_iter, &_obj->_data));
  }

  return caut_status_ok;
}
